import numpy as np
import pandas as pd

import os
import json

def extract_qualityestimates(
    logfile:str=None
):
	"""
	Extracting quality estimates from log files during dataset generation
	Args:
		logfile (str): Path to logfile containing quality estimations. (Default: None)
	"""
	f = open(logfile)
	I = json.load(f)
	f.close()

	Quality_Estimations = {}

	for metric in I['pooled_metrics']:
		Quality_Estimations[metric] = I['pooled_metrics'][metric]['mean']

	for metric in ["psnr_y", "float_ssim", "float_ms_ssim", "vmaf"]:
		if metric not in Quality_Estimations:
			Quality_Estimations[metric] = -1

	Quality_Estimations["frame_level_info"] = I["frames"]
	
	return Quality_Estimations


def extract_execution_time(O):
	"""
	Args:
		O (str): Output of the the process executed with /usr/bin/time as prefix to the command of execution.
	"""

	time_info = O.splitlines()[-2:]
	time_info = time_info[0].split()[0:2]
	usr_time = np.round(float(time_info[0][:-4]), decimals=4)
	sys_time = np.round(float(time_info[1][:-6]), decimals=4)
	total_execution_time = np.round(usr_time + sys_time, decimals=4)

	return total_execution_time


def extract_bitrate(O):
	"""
	Args:
		O (str): Output of the the process executed with /usr/bin/time as prefix to the command of execution.
	"""
	O = O.split("\n")
	bitrate = int(O[0])

	return bitrate


def extract_compression_logs(logs):
	"""
	Args:
		logs (str): Output of the the process executed with /usr/bin/time as prefix to the command of execution.
	"""
	logs = logs.split("\n")
	maps = {}
	for i in range(len(logs)):
		if "x265 [info]: frame I:" in logs[i]:
			maps["I"] = logs[i]
		elif "x265 [info]: frame P:" in logs[i]:
			maps["P"] = logs[i]
		elif "x265 [info]: frame B:" in logs[i]:
			maps["B"] = logs[i]
		else:
			None

	output = {}
	for type,log in maps.items():
		log = log.split(" ")
		info = []
		for s in log:
			if len(s) > 0:
				info.append(s)

		output[type + "_frame_Count"] = int(info[4][:-1])
		output[type + "_frame_AvgQP"] = float(info[6][3:])
		output[type + "_frame_Bitrate"] = float(info[-1])*1000
		
	return output


def Extract_RQ_Information(
	video_rq_points_info:dict=None,
	quality_metric:str=None,
	resolutions:list=None,
	CRFs:list=None,
	bitrates:list=None,
	QPs:list=None,
	min_quality=-np.inf,
	max_quality=np.inf,
	min_bitrate=-np.inf,
	max_bitrate=np.inf,
	set_bitrate_log_base=2
):
	"""
	Extracting rate-quality information from the dataset generated by encoding uncompressed videos using multiple compression settings.
	Args:
		video_rq_points_info (dict): Estimations of a uncompressed video under different compression settings extracted from json file. (Default: None)
		quality_metric (str): Selected quality-metric. Options: ["psnr_y", "integer_motion2", "integer_motion","integer_adm2","integer_adm_scale0","integer_adm_scale1","integer_adm_scale2","integer_adm_scale3","float_ssim","integer_vif_scale0","integer_vif_scale1","integer_vif_scale2","integer_vif_scale3","float_ms_ssim","vmaf"] (Default: None)
		resolutions (list): Resolutions that needs to be considered while plotting RQ points. (Default: None)
		CRFs (list): CRFs that needs to be considered while plotting RQ points. (Default: None)
		bitrates (list): Bitrates that needs to be considered (in kbps) while plotting RQ points. (Default: None)
		QPs (list): QPs that needs to be considered while plotting RQ points. (Default: None)
		min_quality (float): Minimum quality to be considered for in output pairs/info. (Default: -np.inf)
		max_quality (float): Maximum quality to be considered for in output pairs/info. (Default: np.inf)
		min_bitrate (float): Minimum bitrate (in kbps) to be considered for in output pairs/info. (Default: -np.inf)
		max_bitrate (float): Maximum bitrate (in kbps) to be considered for in output pairs/info. (Default: np.inf)
		set_bitrate_log_base (float): Base value of logarithm that needs to applied on bitrate. If None, log Operation will not be applied (Default: None)
	Return:
		RQ_pairs (dict): Dictionary with resolution as keys containing (bitrate (in kbps), quality, rate_control_setting_value) points extracted from selected rate_control json file.
	"""

	# Assertions
	valid_rate_settings = ((QPs is not None) and (CRFs is None) and (bitrates is None)) or ((QPs is None) and (CRFs is not None) and (bitrates is None)) or ((QPs is None) and (CRFs is None) and (bitrates is not None))
	assert valid_rate_settings, "Provide valid rate-control settings i.e only one list of QPs, CRFs or bitrates"
	assert quality_metric in ["psnr_y", "integer_motion2", "integer_motion","integer_adm2","integer_adm_scale0","integer_adm_scale1","integer_adm_scale2","integer_adm_scale3","float_ssim","integer_vif_scale0","integer_vif_scale1","integer_vif_scale2","integer_vif_scale3","float_ms_ssim","vmaf"], "Provide valid quality metric"
	
	# Rate-Control
	rate_control = CRFs if CRFs is not None else (bitrates if bitrates is not None else QPs)

	# Output
	RQ_pairs = {}

	for res in resolutions:
		res_string = str(res[0])+"x"+str(res[1])
		RQ_pairs[res] = []

		for rc in rate_control:
			rc_string = str(rc)

			R = np.round(video_rq_points_info[res_string][rc_string]["bitrate"], decimals=8)
			Q = np.round(video_rq_points_info[res_string][rc_string][quality_metric], decimals=3)

			if (R >= min_bitrate and R <= max_bitrate) and (Q >= min_quality and Q <= max_quality):
				if set_bitrate_log_base is not None:
					R = np.round(np.log10(R)/np.log10(set_bitrate_log_base), decimals=4)
				else:
					R = np.round(R/1000.0, decimals=4)

				RQ_pairs[res].append([R,Q,rc])

		RQ_pairs[res].sort()
		RQ_pairs[res] = np.array(RQ_pairs[res])

	return RQ_pairs